---\rtitle: 事务\ricon: /logo/DBeaver.png\rcreateTime: 2024/09/25 16:30:24\rpermalink: /interview/znj7ig7o/\r---\r::: tip 提问\r1. 是否有了解过分布式事务的一致性, 底层如何实现?\r2. 数据库的事务是什么?\r3. 脏读, 重复读是什么?\r4. 数据库事务的隔离级别?\r:::\r## 分布式事务一致性\r### 2PC\r**第一阶段**\r协调者向所有参与者发送命令, 参与者锁定资源, 本地执行. 如果执行成功则向协调者发送`ready`, 失败则发送`fail`\r\r**第二阶段**\r如果所有协调者都发送了`ready`则协调者向所有参与者发送`commit`, 否则发送`rollback`全部参与者都进行回退.\r\r### TCC\r在2PC的基础上先检查参与者的心跳, 保证参与者都能响应命令.\r\r> 阿里提供`Seata`中间件可以保证分布式事务的一致性.\r\r## 事务\r事务（Transaction）指一个操作, 由多个步骤组成, 要么全部成功, 要么全部失败.\r\r- 原子性\r- 一致性\r- 持久性\r- 隔离性\r\r## 脏读/不可重复读/幻读\r1. 脏读\r   \r   读取未提交的数据\r2. 不可重复读\r   \r   前后多次读取的数据内容不一致\r\r3. 幻读\r   \r   前后多次读取数据的总量不一致\r\r## 事务隔离级别\r### 读未提交(Read Uncommited)\r相当于没有做任何处理, 并发会导致的问题全部都会出现\r\r### 读已提交(Read Commited)\r只能读其他事务已经提交的数据, 可解决**脏读**问题.\r\r==是大多数数据库的隔离级别, 但是不包括MySQL==\r\r### 可重复读(Repeatable Read)\r在某事务的执行过程中不允许其他事务`update`, 但是允许`insert`\r\r==MySQL使用的级别==\r\r### 可串行化(Serializable)\r所有的事务串行执行, 不存在并发冲突.\r\r|          | 脏读               | 不可重复读         | 幻读               |\r| -------- | ------------------ | ------------------ | ------------------ |\r| 读未提交 | :x:                | :x:                | :x:                |\r| 读已提交 | :heavy_check_mark: | :x:                | :x:                |\r| 可重复读 | :heavy_check_mark: | :heavy_check_mark: | :x:                |\r| 可串行化 | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\r