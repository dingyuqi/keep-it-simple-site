---\rtitle: 迪米特法则\rcreateTime: 2022/04/14 00:00:00\rtags:\r  - 设计模式\rpermalink: /designModel/r18tx5ar/\r---\r## 定义\r迪米特法则(Law of Demeter, LoD)又叫作最少知识原则(Least Knowledge Principle, LKP)\r\r定义: 只与你的直接朋友交谈, 不跟"陌生人"说话(Talk only to your immediate friends and not to strangers)\r\r含义: 如果两个软件实体无须直接通信, 那么就不应当发生直接的相互调用, 可以通过第三方转发该调用. 其目的是降低类之间的耦合度, 提高模块的相对独立性. \r\r迪米特法则中的"朋友"是指: 出现在成员变量、方法的输入输出参数中的类就是直接的朋友\r\r## 为什么要用迪米特原则\r类与类之间的关系越密切, 耦合度越大, 当一个类发生改变时, 对另一个类的影响也越大. \r\r### 优点\r降低了类之间的耦合度, 提高了模块的相对独立性. \r\r由于亲合度降低, 从而提高了类的可复用率和系统的扩展性. \r\r### 缺点\r系统中存在大量的中介类, 增加了系统的复杂度\r\r## 实现方法\r1. 在类的划分上, 应该创建弱耦合的类. 类与类之间的耦合越弱, 就越有利于实现可复用的目标. \r\r2. 在类的结构设计上, 尽量降低类成员的访问权限. \r\r3. 在类的设计上, 优先考虑将一个类设置成不变类. \r\r4. 在对其他类的引用上, 将引用其他对象的次数降到最低. \r\r5. 不暴露类的属性成员, 而应该提供相应的访问器(set 和 get 方法). \r\r6. 谨慎使用序列化(Serializable)功能. \r\r    需要使用序列化的场景: 在当前程序之外保存对象并在需要的时候重新获获取对象\r\r    违背迪米特法则的地方: 序列化不必要地暴露了内部的实现 + 容易使得一个类对其最初的内部表示产生依赖\r\r\r\r## 例子\r1. 明星-经纪人\r![明星-经纪人实例类图](/screen_shot/demeter-example.png)\r\r2. 客户-送奶工\r场景: 送奶工把"鲜奶"送到客户的家里, 并且从客户手中得到相应的"报酬"\r\r**客户**\r```python\rpackage test;\rpublic class Customer {\r    private String name;//客户姓名\r    private Wallet Wallet;//客户的钱包\r \r    public Customer(String name, test.Wallet wallet) {\r        this.name = name;\r        Wallet = wallet;\r    }\r \r    public String getName() {\r        return name;\r    }\r \r    public Wallet getWallet() {\r        return Wallet;\r    }\r}\r```\r\r**钱包**\r```python\rpackage test;\r \rpublic class Wallet {\r    private float value;//钱包内的价值\r \r    public Wallet(float value) {\r        this.value = value;\r    }\r \r    /**\r     * @return 返回当前钱包内的总额\r     */\r    public float getTotalMoney() {\r        return value;\r    }\r \r    /**\r     * @param deposit 向钱包中加入的金额数量\r     */\r    public void addMoney(float deposit) {\r        value += deposit;\r    }\r \r    /**\r     * @param debit 需要从钱包中扣除的金额数量\r     */\r    public void subtractMoney(float debit) {\r        value -= debit;\r    }\r \r}\r```\r\r**送奶工**\r```python\rpackage test;\r \rpublic class MilkMan {\r    /**\r     * 送奶工执行"交易"\r     *\r     * @param payment  送奶工应收取的费用\r     * @param customer 被收取费用的客户对象\r     */\r    public void makeDeal(float payment, Customer customer) {\r        Wallet wallet = customer.getWallet();\r        //获取客户的钱包\r        if (wallet.getTotalMoney() >= payment) {\r            wallet.subtractMoney(payment);\r            //从客户的钱包中减去相应的金额\r            System.out.println("交易产生: 送奶工从钱包中成功拿走" + payment + "元");\r        }\r    }\r}\r\r```\r\r**驱动**\r```python\rpackage test;\r \rpublic class Driver {\r    public static void main(String[] args) {\r        //先构造钱包类\r        Wallet wallet = new Wallet(100);\r        //在构造客户类\r        Customer customer = new Customer("小明", wallet);\r        //构构造送奶工\r        MilkMan milkMan = new MilkMan();\r        //模拟送奶工和客户之间的交易\r        milkMan.makeDeal(5, customer);\r    }\r}\r\r```\r\r\r### 问题\r1. 送奶工直接从钱包里面拿钱\r\r2. 客户无法控制拿钱的多少\r\r3. 直接暴露了客户有一个钱包\r\r4. 当钱包的实现发生了变化, 送奶工的函数也需要发生变化\r\r\r\r### 解决办法\r1. 重写"客户"和"送奶工"两个类\r\r**new客户**\r```python\rpackage test;\r \rpublic class Customer2 {\r    private String name;//客户姓名\r    private Wallet wallet;//客户的钱包\r \r    public Customer2(String name, test.Wallet wallet) {\r        this.name = name;\r        wallet = wallet;\r    }\r \r    /**\r     * 由送奶工获取顾客的钱包变成顾客自己使用钱包支付费用\r     *\r     * @param bill 顾客支付的费用\r     * @return 支付的费用\r     */\r    public float getPayment(float bill) {\r        if (wallet != null) {\r            if (wallet.getTotalMoney() > bill) {\r                wallet.subtractMoney(bill);\r            }\r        }\r        return bill;\r    }\r \r    public String getName() {\r        return name;\r    }\r \r    public test.Wallet getWallet() {\r        return wallet;\r    }\r}\r\r```\r\r\r**new送奶工**\r```python\rpackage test;\r \rpublic class MilkMan2 {\r \r    /**\r     * 送奶工执行"交易\r     *\r     * @param payment  送奶工应收取的费用\r     * @param customer 被收取费用的客户对象\r     */\r    public void makeDeal(float payment, Customer2 customer) {\r        //此处不再获取顾客的钱包, 而是要求顾客自己支付费用\r        float customerPayment = customer.getPayment(payment);\r        System.out.println("感谢您的订购！");\r    }\r}\r```\r\r**new驱动**\r```python\rpackage test;\r \rpublic class Driver {\r    public static void main(String[] args) {\r        //先构造钱包类\r        Wallet wallet = new Wallet(100);\r        //在构造客户类\r        Customer2 customer = new Customer2("小明", wallet);\r        //构构造送奶工\r        MilkMan2 milkMan2 = new MilkMan2();\r        //模拟送奶工和客户之间的交易\r        milkMan2.makeDeal(5, customer);\r    }\r}\r```\r\r\r\r### 为什么变好了？\r1. 送奶工没有直接从客户手里拿钱, 而是客户主动发起付款. \r\r2. 客户的Wallet类可以随时改变, 但是送奶工的类不需要改变. \r\r3. 客户给送奶工仅暴露getPayment()函数, 而不暴露付款当中"拿出钱包", "检查钱包里的钱够不够", "取钱"等动作. \r\r\r\r## 总结\r方法不能乱调用, 必须调用下面类型的方法才满足"迪米特法则": \r\r1. 当前对象的其他方法, 即同一个类中的其他方法. \r\r2. 传递进来的参数对象的方法. \r\r3. 在方法中自己实例化的任何对象的方法. \r\r4. 当前对象内部的组件的方法, 即当前对象定义的属性对象的方法. \r\r