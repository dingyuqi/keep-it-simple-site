---\rtitle: 依赖倒置原则\rcreateTime: 2022/03/25 00:00:00\rtags:\r  - 设计模式\rpermalink: /designModel/hp4bylot/\r---\r## 原始定义\r\r1. 高层模块不应该依赖低层模块, 两者都应该依赖其抽象\r\r2. 抽象不应该依赖细节, 细节应该依赖抽象\r\r## 举个例子\r\r1. 假设有一个人要抽一份明星的图\r\r  ```python\r  class Iger():\r    \r    def extract_star():\r      Star().extract()\r    \r  ```\r\r  ```python\r  class Star()\r\r      def extract():\r          print("抽明星图")\r  ```\r\r2. 业务不断扩展, 小明要抽的具体的图越来越多, 有 20 个具体的图\r\r  ```python\r  class Iger():\r    \r    def extract_star():\r      Star().extract()\r      \r\r      # 20个抽具体图的方法\r      \r      def extract_unicom():\r          Unicom().extract()\r  ```\r\r\r\r  ```python\r  class Star():\r      \r      def extract():\r          print("抽明星的图")\r      \r\r      # 20个抽具体图的方法\r\r      \r  class Unicom():\r      \r      def extract():\r          print("抽联通的图")\r  ```\r\r**每一次业务的增加, 都要修改原有的顶层类 Iger, 增加新的 extract 方法**\r\r## 为什么需要依赖倒置原则\r\r### 原因一: 有效控制影响范围\r\r**因为「业务的扩展」, 要从底层实现到高层调用依次地修改代码**\r\rIger 类中新增 `extract_unicom` 方法, 也需要在高层调用中增加调用系统发布后, 其实是非常不稳定的\r\r实际的情况和实际的软件环境要复杂得多. \r\r**最理想的情况就是, 我们已经编写好的代码可以 "万年不变"**, 这就意味着已经覆盖的**单元测试可以不用修改**, 已经存在的行为可以保证保持不变, 这就意味着「稳定」. **任何代码上的修改带来的影响都是有未知风险的, 不论看上去多么简单. **\r\r### 原因二: 增强代码可读性和可维护性\r\r另外一点, 你有没有发现其实加上新增的图的抽取, 这些抽图本质上行为都是一样的, 如果我们任由这样行为近乎一样的代码在我们的类里面肆意扩展的话, 很快我们的类就会变得臃肿不堪, 等到我们意识到不得不重构这个类以缓解这样的情况的时候, 或许成本已经变得高得可怕了. \r\r### 原因三: 降低类间的耦合性\r\r出现了一连串的对象依赖, 从而造成了严重的耦合灾难. \r\r## 怎么做\r\r**面向抽象类的编程来降低类间的耦合性**\r\r```python\rclass Iger():\r	\r	def extract(graph):\r		graph.extract()\r```\r\r**每次增加新的图类型, 不需要修改上层的 Iger 类**\r\r**只需要增加新的图类型, 通过参数传递的方式联系**\r\r```python\rclass Graph(abc.ABC):\r	\r	def extract():\r		pass\r```\r\r```python\rclass Star(Graph):\r	\r	def extract():\r		print("抽明星的图")\r```\r\r```python\rclass Unicom(Graph):\r	\r	def extract():\r		print("抽联通的图")\r```\r\r```python\riger = Iger()\riger.extract(Star())\riger.extract(Unicom())\r```\r\r至此, Iger 就只是依赖 **抽象类**图, 而不是**具体的**明星图、联通图等. \r\r对于新的图, 都只需要新建一个类, 通过参数传递的方式告诉它, **而不需要修改底层的代码**.\r