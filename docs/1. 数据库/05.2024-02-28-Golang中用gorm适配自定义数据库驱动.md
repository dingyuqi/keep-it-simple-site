---\rtitle: Go中使用gorm适配自定义数据库驱动\rcreateTime: 2024/02/28 16:36:32\rtags:\r  - Go\rpermalink: /article/i7zfs74a/\r---\r\rGORM 官方支持的数据库类型有: MySQL, PostgreSQL, SQLite, SQL Server 和 TiD. 但是我们有的时候需要使用gorm接入一些其他自定义的数据库, 例如: [Oracle](https://www.oracle.com/)或者[Yashan](https://yashandb.com/).\r\r在本文中, 我们将介绍如何在 Go 中使用 gorm 这个流行的 ORM 框架来连接 Yashan 数据库, 并进行一些基本的增删改查操作.\r\r## 先决条件\r\r在开始之前, 我们需要准备以下内容: \r\r- 一台安装了 Yashan 数据库的服务器, 以及一个可以访问的数据库用户和密码. 在本文中, 我们假设服务器的 IP 地址是 `192.168.1.100`, 端口号是 `1688`, 数据库名是 `yasdb`, 用户名是 `sys`, 密码是 `123456`. \r- 一台安装了 Go 的开发环境, 以及设置好了 `GOPATH` 和 `GOROOT` 环境变量. 在本文中, 我们假设 Go 的版本是 `1.20`, 并且使用了 `go mod` 来管理依赖包. \r- 一个可以编写和运行 Go 代码的编辑器或 IDE. \r\r\r\r## 安装gorm和驱动\r\r要使用 gorm 来链接 Yashan 数据库, 我们需要安装 gorm 本身, 以及一个适用于 Yashan 的驱动. 由于当前 Yashan 官网上未给出 Go 语言的相关驱动, 我们使用官网提供的 C 驱动然后利用 go 调用 C 实现.\r\r```\rgo get -u gorm.io/gorm\r```\r\r执行上述命令后, 我们在 Go 项目中成功安装了 gorm\r\r## 连接数据库\r\r首先我们来看一下 gorm 内部支持的数据库是如何连接的.\r\r```go\rimport (\r  "gorm.io/driver/postgres"\r  "gorm.io/gorm"\r)\r\rdsn := "host=localhost user=gorm password=gorm dbname=gorm port=9920 sslmode=disable TimeZone=Asia/Shanghai"\rdb, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})\r```\r\r从 [gorm 官方文档-Open](https://pkg.go.dev/gorm.io/gorm@v1.25.7#Open)中可以看到, `func Open` 接受一个 [Dialector](https://pkg.go.dev/gorm.io/gorm@v1.25.7#Dialector) 对象. 而我们现在需要做的就是根据 Yashan 数据库的 C 驱动, 实现 `Dialector` 对象相关的所有接口即可.\r\r```go\rpackage yasdb\r\rimport (\r	"database/sql"\r	"fmt"\r	"github.com/thoas/go-funk"\r	"gorm.io/gorm"\r	"gorm.io/gorm/callbacks"\r	"gorm.io/gorm/clause"\r	"gorm.io/gorm/logger"\r	"gorm.io/gorm/migrator"\r	"gorm.io/gorm/schema"\r	"gorm.io/gorm/utils"\r	"regexp"\r	"strconv"\r	"strings"\r)\r\rconst (\r	driverType = "yasdb"\r)\r\rtype Dialector struct {\r	*Config\r}\r\rfunc (d Dialector) DummyTableName() string {\r	return "DUAL"\r}\r\rtype Config struct {\r	DriverName           string\r	DSN                  string\r	PreferSimpleProtocol bool\r	WithoutReturning     bool\r	Conn                 gorm.ConnPool\r	DefaultStringSize    uint\r}\r\rfunc Open(dsn string) gorm.Dialector {\r	return &Dialector{&Config{DSN: dsn, DefaultStringSize: 255}}\r}\r\rfunc (d Dialector) Name() string {\r	return driverType\r}\r\rfunc (d Dialector) Initialize(db *gorm.DB) (err error) {\r	// register callbacks\r	if !d.WithoutReturning {\r		callbacks.RegisterDefaultCallbacks(db, &callbacks.Config{})\r	}\r	db.ConnPool, err = sql.Open(d.Name(), d.Config.DSN)\r	if err != nil {\r		return\r	}\r	//if err = db.Callback().Create().Replace("gorm:create", Create); err != nil {\r	//	return\r	//}\r	//for k, v := range d.ClauseBuilders() {\r	//	db.ClauseBuilders[k] = v\r	//}\r	return\r}\r\rvar numericPlaceholder = regexp.MustCompile(`\$(\d+)`)\r\rtype Migrator struct {\r	migrator.Migrator\r}\r\rfunc (d Dialector) Migrator(db *gorm.DB) gorm.Migrator {\r	return Migrator{\r		Migrator: migrator.Migrator{\r			Config: migrator.Config{\r				DB:                          db,\r				Dialector:                   d,\r				CreateIndexAfterCreateTable: true,\r			},\r		},\r	}\r}\r\rfunc (d Dialector) DefaultValueOf(*schema.Field) clause.Expression {\r	return clause.Expr{SQL: "VALUES (DEFAULT)"}\r}\r\rfunc (d Dialector) BindVarTo(writer clause.Writer, stmt *gorm.Statement, v interface{}) {\r	_, err := writer.WriteString(":")\r	if err != nil {\r		return\r	}\r	_, err2 := writer.WriteString(strconv.Itoa(len(stmt.Vars)))\r	if err2 != nil {\r		return\r	}\r}\r\rfunc (d Dialector) QuoteTo(writer clause.Writer, str string) {\r	var (\r		underQuoted, selfQuoted bool\r		continuousBacktick      int8\r		shiftDelimiter          int8\r	)\r\r	for _, v := range []byte(str) {\r		switch v {\r		case '"':\r			continuousBacktick++\r			if continuousBacktick == 2 {\r				_, err := writer.WriteString(`""`)\r				if err != nil {\r					return\r				}\r				continuousBacktick = 0\r			}\r		case '.':\r			if continuousBacktick > 0 || !selfQuoted {\r				shiftDelimiter = 0\r				underQuoted = false\r				continuousBacktick = 0\r				err := writer.WriteByte('"')\r				if err != nil {\r					return\r				}\r			}\r			err := writer.WriteByte(v)\r			if err != nil {\r				return\r			}\r			continue\r		default:\r			if shiftDelimiter-continuousBacktick <= 0 && !underQuoted {\r				err := writer.WriteByte('"')\r				if err != nil {\r					return\r				}\r				underQuoted = true\r				if selfQuoted = continuousBacktick > 0; selfQuoted {\r					continuousBacktick -= 1\r				}\r			}\r\r			for ; continuousBacktick > 0; continuousBacktick -= 1 {\r				_, err := writer.WriteString(`""`)\r				if err != nil {\r					return\r				}\r			}\r\r			err := writer.WriteByte(v)\r			if err != nil {\r				return\r			}\r		}\r		shiftDelimiter++\r	}\r\r	if continuousBacktick > 0 && !selfQuoted {\r		_, err := writer.WriteString(`""`)\r		if err != nil {\r			return\r		}\r	}\r	err := writer.WriteByte('"')\r	if err != nil {\r		return\r	}\r}\r\rfunc (d Dialector) Explain(sql string, vars ...interface{}) string {\r	return logger.ExplainSQL(sql, numericPlaceholder, `'`, funk.Map(vars, func(v interface{}) interface{} {\r		switch v := v.(type) {\r		case bool:\r			if v {\r				return 1\r			}\r			return 0\r		default:\r			return v\r		}\r	}).([]interface{})...)\r}\r\rfunc (d Dialector) DataTypeOf(field *schema.Field) string {\r	if _, found := field.TagSettings["RESTRICT"]; found {\r		delete(field.TagSettings, "RESTRICT")\r	}\r\r	var sqlType string\r\r	switch field.DataType {\r	case schema.Bool, schema.Int, schema.Uint, schema.Float:\r		sqlType = "INTEGER"\r		switch {\r		case field.DataType == schema.Float:\r			sqlType = "FLOAT"\r		case field.Size <= 8:\r			sqlType = "SMALLINT"\r		case field.Size >= 64:\r			sqlType = "BIGINT(8)"\r		}\r\r		if val, ok := field.TagSettings["AUTOINCREMENT"]; ok && utils.CheckTruth(val) {\r			sqlType += " GENERATED BY DEFAULT AS IDENTITY"\r		}\r	case schema.String:\r		size := field.Size\r		defaultSize := d.DefaultStringSize\r		if size == 0 {\r			if defaultSize > 0 {\r				size = int(defaultSize)\r			} else {\r				hasIndex := field.TagSettings["INDEX"] != "" || field.TagSettings["UNIQUE"] != ""\r				// TEXT, GEOMETRY or JSON column can't have a default value\r				if field.PrimaryKey || field.HasDefaultValue || hasIndex {\r					size = 191 // utf8mb4\r				}\r			}\r		}\r\r		if size >= 2000 {\r			sqlType = "CLOB"\r		} else {\r			sqlType = fmt.Sprintf("VARCHAR2(%d)", size)\r		}\r\r	case schema.Time:\r		sqlType = "TIMESTAMP"\r		if field.NotNull || field.PrimaryKey {\r			sqlType += " NOT NULL"\r		}\r	case schema.Bytes:\r		sqlType = "BLOB"\r	default:\r		sqlType := string(field.DataType)\r\r		if strings.EqualFold(sqlType, "text") {\r			sqlType = "CLOB"\r		}\r\r		if sqlType == "" {\r			panic(fmt.Sprintf("invalid sql type %s (%s) for oracle", field.FieldType.Name(), field.FieldType.String()))\r		}\r\r		notNull, _ := field.TagSettings["NOT NULL"]\r		unique, _ := field.TagSettings["UNIQUE"]\r		additionalType := fmt.Sprintf("%s %s", notNull, unique)\r		if value, ok := field.TagSettings["DEFAULT"]; ok {\r			additionalType = fmt.Sprintf("%s %s %s%s", "DEFAULT", value, additionalType, func() string {\r				if value, ok := field.TagSettings["COMMENT"]; ok {\r					return " COMMENT " + value\r				}\r				return ""\r			}())\r		}\r		sqlType = fmt.Sprintf("%v %v", sqlType, additionalType)\r	}\r\r	return sqlType\r}\r```\r\r\r\r现在, 我们即可以使用以下代码进行数据库的连接了.\r\r```go\r\rimport (\r	"fmt"\r	// 此处需要引入驱动外部库\r	"gorm.io/gorm"\r	"strings"\r)\r\rconst (\r	connectFormat = `%s/%s@%s:%s`\r)\r\rfunc InitYashan() {\r	replacer := strings.NewReplacer("@", "\\@", "/", "\\/", "\\", "\\\\")\r	datasource := config.Conf.Datasource\r	dsn := fmt.Sprintf(connectFormat, replacer.Replace(datasource.Username), replacer.Replace(datasource.Password), datasource.Host, datasource.Port)\r	yasDB, err := gorm.Open(Open(dsn), &gorm.Config{})\r	// 检查是否有错误\r	if err != nil {\r		fmt.Println("连接数据库失败: ", err)\r		panic(err)\r	}\r	dataBaseModel, err := yasDB.DB()\r	if err != nil {\r		global.LOG.Error("连接数据库失败, error=" + err.Error())\r		panic(err)\r	}\r	dataBaseModel.SetMaxOpenConns(datasource.MaxOpenConns)\r	dataBaseModel.SetMaxIdleConns(datasource.MaxIdleConns)\r}\r\r```\r\r\r<br /><br /><br />\r\r::: info 本文参考资料\r1. [在 Go 中使用 gorm 连接 Oracle](https://www.sjkjc.com/posts/Go-gorm-oracle/)\r2. [GORM官网-连接到数据库-自定义驱动](https://gorm.io/zh_CN/docs/connecting_to_the_database.html)\r:::\r