---
title: Kafka 相关的基本概念和常见问题
tags:
  - 分布式
  - 大数据
  - 中间件
cover: /logo/Kafka.png
createTime: 2024/11/12 14:38:28
permalink: /article/wsep5mda/
---
Kafka 是目前最主流的分布式流式处理平台, 它以高吞吐、可持久化、可水平扩展、支持流式数据处理等多种特性而被广泛使用. 
<!-- more -->

主要的运用场景有三种:
- ***消息系统***: 在传统的消息系统的功能, 如: 系统解耦, 流量削峰, 缓冲, 异步通信等基础上, Kafka 还提供了大多数消息系统无法提供的消息顺序保障以及回溯消费的功能.
- ***存储系统***: Kafka 会把消息持久化到磁盘, 并且拥有多副本机制.
- ***流式处理平台***: Kafka 不仅仅为每个流行的流式处理平台提供了可靠的数据来源, 还提供了一个完整的流式处理类库.

::: info 本文只是我个人对于 Kafka 一些基础概念的笔记以及对工作中常见问题的记录, 并非一个严格的新手教学, 对里面的概念不会做过多的解释. 比较适合对 Kafka 已经有一定概念的人进行复习和查找阅读.
:::

## 基本概念
1. Producer
   
   生产者, 发消息的一方. 生产者负责创建消息, 然后将其发送到 Kafka 中.
2. Consumer
   
   消费者, 接受消息的一方. 消费者连接到 Kafka 并接收消息, 然后进行相关的业务逻辑处理.
3. Broker
   
   服务代理节点. 可以看走一台 Kafka 服务器.
4. Topic
   
   主题. 逻辑上的概念, 方便将消息分类. 
   ::: note 一个 Topic 可以横跨多个 Broker
5. Partition
   
   分区. 一个 Topic 下会有许多分区.
   ::: important Partition 内的消息有序, 而 Topic 内的消息不保证有序
6. Replica
   
   多副本机制. 副本之间保持 "一主多从" 关系. leader-Partition 负责读写, follower-Partition 只负责同步数据.
7. AR
   
   Partition 中所有副本的集合, 包括 leader 本身.
8. ISR
   
   与 leader 保持一定程度上同步的副本集合.
9.  OSR
    
    与 leader 同步关系滞后过多的副本集合.
    ::: note AR = ISR + OSR, 而正常情况下不会有副本同步状态滞后过多, 即 AR = ISR.
10. HW
    
    HighWatermark 的缩写, 即 "高水位". 标识一个特定的 offset, Consumer 只能读到 HW 之前的消息.
11. LEO
    
    Log End Offset 的缩写. 标识下一条即将写入的消息的 offset.

    ![Partition 中各种偏移量的说明](/illustration/kafka-partition-offset-intro.png)

    ::: important ISR 中最小的 LEO 即为 Partition 的 HW.
    HW 不可以被 Consumer 消费, 只能消费 HW 之前的消息. LEO 是下一条被写入消息的 offset, 不是最后一条消息的 offset.

    当一条消息被写入, LEO 立刻 +1, 但是 HW 则与 ISR 中 follower 的同步情况相关. leader 的 HW = ISR 中 follower 最小的 LEO.
    :::
12. zookeeper
    
    是安装 Kafka 集群的必要组件. Kafka 通过 zookeeper 来进行元数据的管理.

## Producer
Kafka 中 Producer 是线程安全的.

发送消息到 Kafka 主要经历以下几个步骤:
::: steps
1. 配置参数创建实例
   
   - bootstrap.servers
   - key.serializer
   - value.serializer
  
2. 构建待发送的消息
   
3. 发送消息
   
   `send()` → 拦截器 → 序列化器 → 分区器 → Broker

4. 关闭实例
:::

## Consumer
Kafka 中 Consumer 是 ==非线程安全的==, 因为有状态.

### Consumer Group
Consumer 负责订阅 Kafka 中的 Topic, 并从订阅的 Topic 中拉取消息. Consumer 有一个逻辑的分组概念: Consumer Group, 每个消费者属于一个消费者组. 当消息被发布到主题后, ==只会被投递给订阅它的每个消费者组中的一个消费者==.

以下几种消费方式 Kafka 都是支持的:

![A single consumer in a consumer group](/illustration/consumer_group_1_member.png)

![Multiple consumers in one consumer group](/illustration/consumer_group.png)

![Multiple consumers reading the same records from the topic](/illustration/consumer_group_2_groups_1_member.png)

::: important 当 Consumer 的个数超过 Partition 个数的时候就会有 Consumer 分配不到任何分区从而不进行任何消费.

![Additional consumers in a group sit idly](/illustration/consumer_group_3_members.png)
:::

### 消费逻辑
::: steps
1. 配置参数创建实例
   
   - bootstrap.servers
   - group.id
   - key.serializer
   - value.serializer
  
2. 订阅 Topic
   
3. 拉取消息并消费
   
4. 提交 offset
   
    提交 `x + 1` 而不是 `x`.

5. 关闭实例
:::

## Rebalance
### 触发场景
1. 有新的 Consumer 加入 Consumer Group.
2. 有 Consumer 宕机下线.
3. 有 Consumer 主动退出 Consumer Group.
4. Consumer Group 订阅的任何 Topic 的分区数量产生变化.

### 第一阶段 FIND_COORDINATOR
Consumer 需要确定其 Consumer Group 对应的 Group Coordinator 的 Broker 并与其建立连接.

如果 Consumer 保存了 Group Coordinator 节点信息且连接正常则进入下一个阶段. 如果没有则向集群负载最小的节点发送 FindCoordinatorRequest.

### 第二阶段 JOIN_GROUP
在成功找到 Consumer Group 对应的 Group Coordinator 后就进入该阶段.

此阶段 Consumer 会向 Group Coordinator 发送 JoinGroupRequest 并处理响应.

#### 选举 Consumer Group 的 leader
如果组内没有 leader, 则加入 Consumer Group 的第一个 Consumer 成为 leader.

如果 leader 退出了 Consumer Group, 则取 Group Coordinator 的 HashMap 中第一对 (key, value) 做为 leader. 这种方式几乎等于随机.

#### 选举分区分配策略
```go
// TODO
```

### 第三阶段 SYNC_GROUP
leader 根据第二阶段选举出来的分区分配策略来实施具体的分配. 在此之前要将分配方案同步给各个 Consumer, 但是不是 leader 自己直接发布, 而是通过 Group Coordinator 发布.

此阶段 Consumer 会向 Group Coordinator 发送 SyncGroupRequest 来同步分配方案.

### 第四阶段 HEARTBEAT
进入该阶段后, Consumer Group 中所有的 Consumer 都可以正常运作. Consumer 和 Group Coordinator 之间会维持心跳. 如果停跳时间过长则会再次触发 Rebalance.

## 总结
本文目前为止介绍了 Kafka 相关的基础知识以及 Rebalance 的相关内容. 随着后续的学习, 本文可能会持续更新.

<br /><br /><br />

::: info 本文参考资料
1. [What is a consumer group in Kafka?](https://codingharbour.com/apache-kafka/what-is-a-consumer-group-in-kafka/)
:::