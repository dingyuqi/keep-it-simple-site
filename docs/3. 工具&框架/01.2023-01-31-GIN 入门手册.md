---\rtitle: GIN 入门手册\rcreateTime: 2023/01/31 00:00:00\rtags:\r  - Go\rpermalink: /article/1hbzg38x/\r---\r## 简介\r\rGin 是一个用 Go 编写的 Web 框架. \r\r使用包 :   ```import "github.com/gin-gonic/gin"```\r\r<!-- more -->\r\r## 常用的结构和代码\r### 最简单的Demo\r\r``` go\rpackage main\r\rimport "github.com/gin-gonic/gin"\r\rfunc main() {\r  r := gin.Default()\r  r.GET("/ping", func(c *gin.Context) {\r    c.JSON(200, gin.H{\r      "message": "pong",\r    })\r  })\r  r.Run() // 监听并在 0.0.0.0:8080 上启动服务\r}\r```\r\r### Group路由组\r类似于Flask中的blueprint, 用于组织路由地址的层次.\r\r```go\rfunc main() {\r  router := gin.Default()\r\r  // 简单的路由组: v1\r  v1 := router.Group("/v1")\r  {\r        v1.GET("/login", loginHandler()) //url: http://0.0.0.0:8080/v1/login\r        v1.GET("/setting", settingHandler()) //url: http://0.0.0.0:8080/v1/setting\r  }\r\r  router.Run(":8080")\r}\r\r//定义中间件\rfunc loginHandler() gin.HandlerFunc {\r  return func(c *gin.Context) {\r    c.JSON(200, gin.H{\r      "message": "successfully login!!",\r    })\r  }\r}\rfunc settingHandler() gin.HandlerFunc {\r  return func(c *gin.Context) {\r    c.JSON(200, gin.H{\r      "message": "successfully setting!!",\r    })\r  }\r}\r```\r\r### 中间件\r\r中间件是Gin中非常非常重要的一个部分.\r\r#### 中间件的作用:\r\r1. Web请求到到达我们定义的HTTP请求处理方法之前, 拦截请求并进行相应处理(比如: 权限验证, 数据过滤等), 这个可以类比为前置拦截器或前置过滤器, \r2. 在我们处理完成请求并响应客户端时, 拦截响应并进行相应的处理(比如: 添加统一响应部头或数据格式等), 这可以类型为后置拦截器或后置过滤器. \r\r中间件实际上就是一个以gin.Context为形参的函数\r\rGin中有许多内置的中间件\r\r```go\rfunc BasicAuth(accounts Accounts) HandlerFunc\rfunc BasicAuthForRealm(accounts Accounts, realm string) HandlerFunc\rfunc Bind(val interface{}) HandlerFunc\rfunc ErrorLogger() HandlerFunc\rfunc ErrorLoggerT(typ ErrorType) HandlerFunc\rfunc Logger() HandlerFunc\rfunc LoggerWithConfig(conf LoggerConfig) HandlerFunc\rfunc LoggerWithFormatter(f LogFormatter) HandlerFunc\rfunc LoggerWithWriter(out io.Writer, notlogged ...string) HandlerFunc\rfunc Recovery() HandlerFunc\rfunc RecoveryWithWriter(out io.Writer) HandlerFunc\rfunc WrapF(f http.HandlerFunc) HandlerFunc\rfunc WrapH(h http.Handler) HandlerFunc\r```\r\r使用示例:\r\r```go\rfunc main() {\r  r := gin.Default()\r\r  r.Use(gin.BasicAuth(gin.Accounts{\r    "admin": "123456",\r  }))\r\r  r.GET("/", func(c *gin.Context) {\r    c.JSON(200, "通过验证, 欢迎进入首页")\r  })\r\r  r.Run(":8080")\r}\r```\r\r#### 中间件的自定义\r\r```go\rfunc MyMiddleware(){\r    return func(c *gin.Context){\r        //do something\r    }\r}\r\r//使用时\r//Default意味着全局中间件\rrouter = gin.Default() \rrouter.Use(MyMiddleware()) //注意MyMiddleware有括号\r\r//Group意味着分组使用\radminGroup := r.Group("/admin")\radminGroup.Use(gin.BasicAuth(gin.Accounts{\r    "admin": "123456"\r}))\radminGroup.GET("/index", func(c *gin.Context) {\r    c.JSON(200, "后台首页")\r})\r```\r\r#### 数据传递\r\r当我们在中间件拦截并预先处理好数据之后, 要如何将数据传递我们定义的处理请求的HTTP方法呢？可以使用`gin.Context`中的`Set()`方法, 其定义如下, `Set()`通过一个key来存储作何类型的数据, 方便下一层处理方法获取. \r\r```go\rfunc MyMiddleware(c *gin.Context){\r    c.Set("mykey",10)\r}\r\rrouter := gin.New()\rrouter.GET("test",MyMiddleware,func(c *gin.Context){\rc.GetInt("mykey")\r})\r```\r\r对应的方法有:\r\r```go\rfunc (c *Context) GetBool(key string) (b bool)\rfunc (c *Context) GetDuration(key string) (d time.Duration)\rfunc (c *Context) GetFloat64(key string) (f64 float64)\rfunc (c *Context) GetInt(key string) (i int)\rfunc (c *Context) GetInt64(key string) (i64 int64)\rfunc (c *Context) GetString(key string) (s string)\rfunc (c *Context) GetStringMap(key string) (sm map[string]interface{})\rfunc (c *Context) GetStringMapString(key string) (sms map[string]string)\rfunc (c *Context) GetStringMapStringSlice(key string) (smss map[string][]string)\rfunc (c *Context) GetStringSlice(key string) (ss []string)\rfunc (c *Context) GetTime(key string) (t time.Time)\r```\r\r#### 拦截请求与后置拦截\r##### 1. 拦截请求\r\r比如我们有些请求需要用户登录或者需要特定权限才能访问, 这时候便可以中间件中做过滤拦截, 当用户请求不合法时, 可以使用下面列出的`gin.Context`的几个方法中断用户请求: \r\r下面三个方法中断请求后, 直接返回200, 但响应的body中不会有数据. \r\r```go\rfunc (c *Context) Abort()\rfunc (c *Context) AbortWithError(code int, err error) *Error\rfunc (c *Context) AbortWithStatus(code int)\r```\r\r使用AbortWithStatusJSON()方法, 中断用户请求后, 则可以返回json格式的数据.\r\r```go\rfunc (c *Context) AbortWithStatusJSON(code int, jsonObj interface{})\r```\r\r##### 2. 后置拦截\r\r前面我们讲的都是到达我们定义的HTTP处理方法前进行拦截, 其实, 如果在中间件中调用`gin.Context`的`Next()`方法, 则可以请求到达并完成业务处理后, 再经过中间件后置拦截处理. \r\r在中间件调用`Next()`方法, `Next()`方法之前的代码会在到达请求方法前执行, `Next()`方法之后的代码则在请求方法处理后执行.\r\r示例:\r\r```go\rfunc MyMiddleware(c *gin.Context){\r    c.Set("key",1000)\r  c.Next()\r  c.JSON(http.StatusOK,c.GetInt("key"))\r}\rrouter := gin.New()\rrouter.GET("/test", MyMiddleware, func(c *gin.Context) {\r  k := c.GetInt("key")\r  c.Set("key", k+2000)\r})\rrouter.Run()\r```\r\r运行结果返回值为3000.\r\r::: info 参考资料\r1. [什么是中间件?](https://cloud.tencent.com/developer/article/1585029)\r2. [中间件实战讲解](https://cloud.tencent.com/developer/article/1652781)\r:::\r\r### 同步响应和异步响应\r\r每次request请求Gin会开启新的goroutine来处理请求. Gin同时支持请求的同步响应和异步响应. 示例如下:\r\r```go\rfunc main() {\r  // 1.创建路由\r  // 默认使用了2个中间件Logger(), Recovery()\r  r := gin.Default()\r  // 1.异步\r  r.GET("/long_async", func(c *gin.Context) {\r    // 必须搞一个副本不能直接传递\r    copyContext := c.Copy()\r    c.JSON(http.StatusOK, "异步调用返回")\r    // 异步处理\r    go func() {\r      log.Println("开始异步执行: " + copyContext.Request.URL.Path)\r      time.Sleep(8 * time.Second)\r      log.Println("结束异步执行: " + copyContext.Request.URL.Path)\r    }()\r  })\r  \r    // 2.同步\r  r.GET("/long_sync", func(c *gin.Context) {\r        log.Println("开始同步执行: " + c.Request.URL.Path)\r    time.Sleep(5 * time.Second)\r    log.Println("开始同步执行: " + c.Request.URL.Path)\r    c.JSON(http.StatusOK, "同步调用返回")\r  })\r  r.Run(":8080")\r\r}\r```\r\r关于父子goroutine 之间的关系可参考: [主goroutine结束, 子goroutine也立即结束?](https://blog.csdn.net/qq_37886086/article/details/116648802) 和 [Goroutine理解](https://zhuanlan.zhihu.com/p/60613088) 两篇博客.\r\r## Docker打包部署\r\r待研究, 看了几个博客, 感觉Go的环境GOPATH, GOROOT啥的比较麻烦\r\r1. [ gin 服务器部署](https://blog.csdn.net/hezhongla0811/article/details/105817730)\r2. [部署go项目到k8s集群 ](https://www.cnblogs.com/guyouyin123/p/15688012.html)\r3. [golang gin 项目部署 docker镜像制作 看这一篇就够了 项目部署一条龙](https://blog.csdn.net/weixin_43273113/article/details/118389186)\r\r<br /><br /><br />\r\r::: info 本文参考资料\r1. [Gin官方文档](https://gin-gonic.com/zh-cn/docs/quickstart/)\r:::